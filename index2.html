<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PWA Repeat Timer</title>

  <!-- Link manifest (create manifest.json in same folder) -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#1f2937">

  <style>
    :root{font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:0}
    body{display:flex;min-height:100vh;align-items:center;justify-content:center;background:#0f172a;color:#e6eef8}
    .card{width:380px;padding:20px;border-radius:12px;background:linear-gradient(180deg,#0b1220, #0f172a);box-shadow:0 6px 30px rgba(2,6,23,.6)}
    h1{font-size:20px;margin:0 0 12px}
    label{font-size:13px;display:block;margin-bottom:6px}
    input[type=number]{width:100%;padding:10px;border-radius:8px;border:1px solid #233240;background:#071020;color:#e6eef8}
    .controls{display:flex;gap:8px;margin-top:10px}
    button{flex:1;padding:10px;border-radius:8px;border:0;background:#2563eb;color:white;cursor:pointer}
    button.secondary{background:#334155}
    .status{margin-top:12px;font-size:14px}
    .small{font-size:13px;color:#94a3b8}
    .footer{margin-top:12px;text-align:center;color:#94a3b8;font-size:13px}
  </style>
</head>
<body>
  <div class="card">
    <h1>PWA Repeat Timer</h1>
    <label for="minutes">Set Timer (HH:MM:SS)</label>
    <!-- <input type="text" id="minutes" value="00:10:00" placeholder="00H:00M:00S"> -->
    <input type="time" id="time" name="time" step="1">

    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="stopBtn" class="secondary">Stop</button>
    </div>

    <div class="status small" id="status">Status: stopped</div>
    <div class="status" id="countdown">—</div>

    <div class="controls" style="margin-top:10px">
      <button id="snoozeBtn" class="secondary">Snooze 1 min</button>
      <button id="resetBtn" class="secondary">Reset</button>
    </div>

    <div class="footer small">Tip: Install as PWA for more reliable background timing.</div>
  </div>

  <!-- Ringtone (place file ringtone.mp3 in same folder or change src) -->
  <audio id="ring" preload="auto" src="ringtone.mp3"></audio>

  <script>
    // Basic app state
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const snoozeBtn = document.getElementById('snoozeBtn');
    const resetBtn = document.getElementById('resetBtn');
    const minutesInput = document.getElementById('minutes');
    const statusEl = document.getElementById('status');
    const countdownEl = document.getElementById('countdown');
    const ring = document.getElementById('ring');

    let timerId = null; // holds timeout id
    let remaining = 0; // ms
    let endTs = 0; // timestamp when timer ends
    let running = false;

    // Register service worker (optional but needed for PWA install)
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').then(() => {
        console.log('SW registered');
      }).catch(err => console.warn('SW reg failed', err));
    }

    let tickInterval = null;

    startBtn.addEventListener('click', async () => {
      await ensureNotificationPermission();
      const minutes = parseFloat(minutesInput.value);
      console.log("time => ", minutes)
      // clear previous tick
      clearInterval(tickInterval);
      scheduleNext(minutes);
    });

    stopBtn.addEventListener('click', () => {
      clearTimeout(timerId);
      clearInterval(tickInterval);
      running = false;
      updateUI();
    });

    snoozeBtn.addEventListener('click', () => {
      // add 1 minute to remaining or if stopped, start 1 minute
      clearTimeout(timerId);
      clearInterval(tickInterval);
      const add = 1; // minute
      if (running) {
        const now = Date.now();
        const remMs = Math.max(0, endTs - now);
        endTs = now + remMs + add * 60 * 1000;
        const ms = endTs - now;
        timerId = setTimeout(onTimerComplete, ms);
      } else {
        scheduleNext(add);
      }
      tickInterval = setInterval(updateUI, 1000);
      running = true;
      updateUI();
    });

    resetBtn.addEventListener('click', () => {
      const minutes = parseFloat(minutesInput.value) || 10;
      clearTimeout(timerId);
      clearInterval(tickInterval);
      scheduleNext(minutes);
    });

    // keep UI updated even if page loses focus
    setInterval(() => {
      if (running) updateUI();
    }, 1000);

    // listen to messages from SW (optional)
    navigator.serviceWorker && navigator.serviceWorker.addEventListener('message', e => {
      console.log('SW msg', e.data);
    });

    // Expose a window event to allow testing when not focused
    window.addEventListener('focus', updateUI);

    // initial UI
    updateUI();

    // Request Notification permission on first user gesture
    async function ensureNotificationPermission() {
      if (!('Notification' in window)) return false;
      if (Notification.permission === 'granted') return true;
      if (Notification.permission !== 'denied') {
        const p = await Notification.requestPermission();
        return p === 'granted';
      }
      return false;
    }

    function formatMs(ms) {
      const s = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(s / 60);
      const sec = s % 60;
      return `${m}:${sec.toString().padStart(2,'0')}`;
    }

    function updateUI() {
      statusEl.textContent = running ? 'Status: running' : 'Status: stopped';
      if (running) {
        const now = Date.now();
        remaining = Math.max(0, endTs - now);
        countdownEl.textContent = 'Remaining: ' + formatMs(remaining);
      } else {
        countdownEl.textContent = '—';
      }
    }

    function scheduleNext(durationMinutes) {
        console.log("time ", durationMinutes)
      clearTimeout(timerId);
      const durationMs = durationMinutes * 60 * 1000;
    //   endTs = Date.now() + durationMs;
    //   running = true;
    //   updateUI();

    //   // Use setTimeout to trigger on completion
    //   timerId = setTimeout(() => {
    //     onTimerComplete();
    //   }, durationMs);

    //   // Update countdown every 1s so UI shows live time
    //   tickInterval = setInterval(updateUI, 1000);
    }

    function onTimerComplete() {
      // Play ringtone
      ring.currentTime = 0;
      const playPromise = ring.play();
      if (playPromise !== undefined) {
        playPromise.catch(e => console.warn('autoplay prevented', e));
      }

      // Show notification (and click handler via service worker if available)
      if (Notification.permission === 'granted') {
        // If service worker is controlling, use it to show notification (better for PWA)
        if (navigator.serviceWorker && navigator.serviceWorker.controller) {
          navigator.serviceWorker.controller.postMessage({type:'show-notification', title:'Timer Done', body:'Timer finished and restarted.'});
        } else {
          new Notification('Timer Done', { body: 'Timer finished and restarted.' });
        }
      }

      // Reset timer to repeat (auto restart)
      const minutes = parseFloat(minutesInput.value) || 10;
      scheduleNext(minutes);
    }

    
  </script>
</body>
</html>